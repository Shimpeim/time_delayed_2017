> #R --vanilla --quiet < Morimoto_TDC.2016.main_20160707_args.R --args Selevsek_2015_all_Selevsek_20160706.RData             out.setting=F clustering=T ScaleBoot=F  lag.neg.ign=T  Selevsek_2015_id.convert_all.csv             > Selevsek_2015.all_Qian.log 2>&1 &
> #R --vanilla --quiet < Morimoto_TDC.2016.main_20160707_args.R --args Selevsek_2015_pentose_Selevsek_20160706.RData         out.setting=F clustering=F ScaleBoot=F  lag.neg.ign=T  Selevsek_2015_id.convert_pentose.csv         > Selevsek_2015.pentose_noHCA.log 2>&1 &
> #R --vanilla --quiet < Morimoto_TDC.2016.main_20160707_args.R --args Selevsek_2015_GlySerThrMetabo_Selevsek_20160706.RData out.setting=F clustering=F ScaleBoot=F  lag.neg.ign=T  Selevsek_2015_id.convert_GlySerThrMetabo.csv > Selevsek_2015.GlySerThrMetabo_noHCA.log 2>&1 &
> #R --vanilla --quiet < Morimoto_TDC.2016.main_20160707_args.R --args Fournier_2010_all_Fournier_20160123.RData             out.setting=F clustering=F ScaleBoot=F  lag.neg.ign=T  Fournier_2010_id.convert_all.csv             > Fournier_2010.all_Qian.log 2>&1 &
> 
> # This source code is built under R ver.3.1.2
> 
> c_args <- commandArgs(trailingOnly=T)
> param.setting     <- c_args[2]
> param.setting <- 'out.setting=F'
> eval(parse(text = param.setting))
> 
> if(out.setting==T){
+   source(file = sprintf(
+     '%s/%s',
+     '/Users/mos/Dropbox/Draft_201603Morimoto/Analysis/PG',
+     'Morimoto_TDC.2016.setting_20160317_args.R')
+   )
+ }else{
+   c_args <- commandArgs(trailingOnly=T)
+   makedataData     <- c_args[1]
+   c_score4HCA      <- c_args[3]
+   c_ScaleBoot      <- c_args[4]
+   c_lag.neg.ign    <- c_args[5]
+   id.convertData   <- c_args[6]
+   
+   outputDirectry.prefix <- './'
+   dataDirectry <- './'
+   funcDirectry <- './'
+   pkgsDirectry  <- './'
+   }
> 
> outprefix      <- sub(".RData", "", makedataData)
> 
> print(makedataData)
[1] "Selevsek_2015_GlySerThrMetabo_Selevsek_20160706.RData"
> print(c_score4HCA)
[1] "clustering=F"
> print(c_ScaleBoot)
[1] "ScaleBoot=F"
> print(c_lag.neg.ign)
[1] "lag.neg.ign=T"
> print(id.convertData)
[1] "Selevsek_2015_id.convert_GlySerThrMetabo.csv"
> 
> 
> eval(parse(text = c_score4HCA))
> eval(parse(text = c_ScaleBoot))
> eval(parse(text = c_lag.neg.ign))
> 
> filter.delay <- c(0,1,2)
> 
> #```{r setup for HCA and def bootstrap filter }
> 
> z_norm            <- TRUE  # Z-Normalize by genes and datanames before E score calc. ?
> interTemporal     <- TRUE  # convert data for E score calc. to inter-temporal  ?
> rho.interTemporal <- FALSE # convert data for corr.Rho calc. to inter-temporal ?
> 
> if(clustering==F){score4HCA='noHCA'}else{
+   score4HCA='Qian,2001'
+ }
> methodHclust <- 'ward.D2'
>   #'ward.D2'#'correlation'
> methodDist   <- 'euclidean'
>   #'euclidean'#'average'
> 
> alpha.au  =  0.95
> alpha.bp  =  0.8
> nboot     =  10000
> scaling_r <- c(seq(.5,1.5,by=.1))
> 
> #```
> 
> #```{r prefix for output files}
> 
> histogram.pdf.prefix        <- 'histogram'
> 
> HCA_by_delay.pdf.prefix     <- 'HCA_delay'
> BP_of_edges.csv.prefix      <- 'BP_of_edges_delay'
> heatmap_by_delay.pdf.prefix <- 'heatmap_delay' 
> 
> line_plot.pdf.prefix        <- 'lines_'
> scat_plot.pdf.prefix        <- 'scatt_'
> 
> uniProtAccess.csv.prefix       <- 'high_BP_uniProtAccess'
> 
> perm_null_rho_histo.pdf.prefix <- 'permNullDistHisto'
> permuted_Rho.csv.prefix        <- 'permuted_Rho'
> 
> RData_PermRhoAnalysis_save.image.prefix <- 'permuted_Rho'
> 
> 
>  # permuted Rho
> 
> itt_of_permute <- 10000
> 
> #```
> 
> #```{r functions sorce code file}
> 
> EscoreCalc <- 'func_for_calcEscore_20160123.R' # modified: 2016/01/23
> pvclustMod <- 'my.pvclust_20151121.R'
> permtRho   <- 'func_for_permutest_of_Rho_20151124.R' 
> dataManu   <- 'OldFunc_20151125.R'
> #```
> 
> 
> #```{r Load libraries}
> 
> ## LIBRARIES
> rm()
> 
> packages <- c(
+   'dplyr', # progress bar
+   'plyr',  # progress bar
+   'dplyr', # progress bar
+   'tidyr',
+   'xlsx',
+   'ggplot2',
+   'gplots',
+   'GMD',
+   'pvclust',
+   'reshape2',
+   'pander',
+   'matrixcalc'
+ #  'scaleboot' 
+ #  'biomaRt'
+   ) 
> 
> new.packages <-
+   packages[!(packages %in% installed.packages())] 
>   # installed.packages() returns installed packages 
> 
> if(length(new.packages) > 0){ 
+   install.packages(new.packages, repos='http://cran.us.r-project.org')
+ }
> require('plyr')  # progress bar
 要求されたパッケージ plyr をロード中です 
> require('dplyr') # progress bar
 要求されたパッケージ dplyr をロード中です 

 次のパッケージを付け加えます: ‘dplyr’ 

 以下のオブジェクトは ‘package:plyr’ からマスクされています: 

     arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize 

 以下のオブジェクトは ‘package:stats’ からマスクされています: 

     filter, lag 

 以下のオブジェクトは ‘package:base’ からマスクされています: 

     intersect, setdiff, setequal, union 

> require('tidyr')
 要求されたパッケージ tidyr をロード中です 
> require('xlsx')
 要求されたパッケージ xlsx をロード中です 
 要求されたパッケージ rJava をロード中です 
 要求されたパッケージ xlsxjars をロード中です 
> require('ggplot2')
 要求されたパッケージ ggplot2 をロード中です 
> require('gplots')
 要求されたパッケージ gplots をロード中です 

 次のパッケージを付け加えます: ‘gplots’ 

 以下のオブジェクトは ‘package:stats’ からマスクされています: 

     lowess 

> require('GMD')
 要求されたパッケージ GMD をロード中です 
> require('pvclust')
 要求されたパッケージ pvclust をロード中です 
> require('reshape2')
 要求されたパッケージ reshape2 をロード中です 
> require('pander')
 要求されたパッケージ pander をロード中です 
> require('matrixcalc')
 要求されたパッケージ matrixcalc をロード中です 
> 
> if( !("biomaRt" %in% installed.packages()) ){
+   source('http://bioconductor.org/biocLite.R')
+   biocLite( 'biomaRt' )
+   require( 'biomaRt' )
+ }else  require( 'biomaRt' )
 要求されたパッケージ biomaRt をロード中です 
> 
> if( !("scaleboot" %in% installed.packages()) ){
+   install.packages(
+     sprintf(fmt = '%s%s',
+             pkgsDirectry,
+             "scaleboot_0.3-3.tar.gz"  
+             # ver. 16-May-2010 16:21
+             # https://cran.r-project.org/src/contrib/Archive/scaleboot/
+             ),
+     repos = NULL, type = "source")
+   require( 'scaleboot' )
+ }else require( 'scaleboot' )
 要求されたパッケージ scaleboot をロード中です 
> 
> #```
> 
> 
> 
> #Functions for data manupilation
> #```{r}
> source(file = sprintf('%s%s',funcDirectry,dataManu)) ## added 2015/11/24 SM
> ## source code was moved to EscoreCalc
> #```
> 
> #Functions for HCA
> #```{r}
> source(file = sprintf('%s%s',funcDirectry,EscoreCalc)) ## added 2015/11/24 SM
> ## source code was moved to EscoreCalc
> #```
> 
> #Functions for pvclust
> #```{r}
> source(file = sprintf('%s%s',funcDirectry,pvclustMod)) ## added 2015/11/24 SM
> ## source code was moved to pvclustMod
> # includes 
> #```
> 
> #Functions for Correlation test
> #```{r}
> source(file = sprintf('%s%s',funcDirectry,permtRho)) ## added 2015/11/24 SM
> ## source code was moved to permRho
> #```
> 
> 
> #```{r Load R_data}
> 
> ## LOAD DATA
> 
> 
> getwd()
[1] "/Users/mos/Dropbox/Draft_201603Morimoto/Analysis/PG/args/20160714"
> 
> load(
+   paste(
+     dataDirectry,
+     makedataData,
+     sep='')
+   )
> 
> #```
> 
> #```{r make Z-normalised and time differencial data}
> 
> if(z_norm == TRUE){  # added: 2016/01/23
+   data_ana_norm <- data_ana %>%
+     rename(val2=val) %>%
+     group_by(id,dtname) %>%  
+     mutate(val=scale(val2, center = TRUE, scale = TRUE)) %>%
+     dplyr::select(-val2)%>%
+     ungroup()%>%
+     data.frame()
+   attributes(data_ana_norm$val) <- NULL
+     
+   if(interTemporal==TRUE){
+     w.dataGQ <- makeDifData(data_ana_norm %>% spread(key=var,value=val),cols) %>%
+       dplyr::select(id,dtname,starts_with('d_'))
+     timePoint <- timePoint-1
+     }
+   }
> 
> dataGQ <- w.dataGQ[duplicated(w.dataGQ$id)|duplicated(w.dataGQ$id,fromLast=TRUE),]
> 
> #```
> 
> 
> #```{r classification by delayed time}
> 
> w.GQSfled_0 <-  ddply(dataGQ,.(id),gq_method2) %>%
+   dplyr::rename(
+     delayE0=X1,
+     scoreE0=X2,
+     delayD0=X1.1,
+     scoreD0=X2.1
+     )
> 
> #```
> 
> #```{r histogram }
> 
> ftable.delay <- data.frame(
+   ftable(w.GQSfled_0$delayE0)
+   ) %>%
+   mutate(
+     delay=as.numeric(as.character(Var1)),
+     total=sum(Freq),
+     prop=paste(round(Freq/total*100,2),'%',sep=''),
+     prop_num = Freq/total*100
+   )
> y.ax.break <- seq(0,max(ftable.delay$Freq),floor(max(ftable.delay$Freq)/10))
> 
> if(lag.neg.ign==T){  
+   # if lag.neg.ign==T then ignor genes whose lag is less than 0
+   # and hide percentages (not plot 'plot.type2' layer).
+   histo_data <- ggplot(data = ftable.delay %>%
+                          filter(delay>=0),
+                        aes(x=delay,y=as.numeric(Freq),group=prop))
+ }else{
+   histo_data <- ggplot(data = ftable.delay,
+                        aes(x=delay,y=as.numeric(Freq),group=prop))
+ }
> 
> plot.type <- geom_bar(stat="identity")
> plot.type2 <- annotate(
+   "text", 
+   label=ftable.delay$prop, 
+   x=ftable.delay$delay, 
+   y=ftable.delay$Freq+y.ax.break[2]/2, 
+   fontface="italic") 
> plot.labs <- labs(x='delay (prt to trc)',y='count (genes)')
> plot.y.axe <- scale_y_continuous(breaks=y.ax.break)
> plot.x.axe <- scale_x_continuous(breaks=ftable.delay$delay)
> plot.axe.text <- theme(
+   axis.text.x = element_text(size=25),
+   axis.text.y = element_text(size=15)) 
> pdf(      
+   sprintf(
+     '%s%s_%s_%s.pdf',
+     outputDirectry.prefix,
+     outprefix,
+     bioproc,
+     histogram.pdf.prefix
+     ) ,
+   width=100,
+   paper='USr'
+   )
> if(lag.neg.ign==T){
+   plot( histo_data + plot.type + plot.labs + plot.y.axe + plot.x.axe + plot.axe.text)
+ }else{
+   plot( histo_data + plot.type + plot.labs + plot.y.axe + plot.x.axe + plot.type2 + plot.axe.text)
+ }
> dev.off()
null device 
          1 
> 
> #```
> #```{r filtering by time lag}
> filter.delay.df <- data.frame(delayE0=filter.delay)
> 
> w.GQSfled_0 <- w.GQSfled_0 %>%
+   inner_join(filter.delay.df)
Joining by: "delayE0"
> GQSfled_0 <- data.frame(ftable(w.GQSfled_0$delayE0)) %>%
+   filter(Freq>2)%>%
+   mutate(delayE0 = as.numeric(as.character(Var1)))%>%
+   dplyr::select(delayE0)%>%
+   inner_join(w.GQSfled_0)
Joining by: "delayE0"
>   
> 
> mst <- dataGQ %>%
+   filter(id %in% GQSfled_0$id)
> 
> #```
> 
> #Hieralchical Clustering Analysis 
> #```{r HCA}
> 
> if(ScaleBoot==TRUE){
+   sb.switch <- '.on_'
+ }else{
+   sb.switch <- '.off_'
+ }
> 
> if(score4HCA != 'noHCA'){
+   if(score4HCA=='Qian,2001'){
+     GQScoreMat_0 <-  ddply(mst,.(id),gq_scoreMatOut)#,.progress='text')
+     }else
+       {
+         if(score4HCA %in% c('trc_prt_1dim'))
+           GQScoreMat_0 <-  mst %>%
+             filter(dtname =='trc') %>%
+             inner_join( mst %>%
+                           filter(dtname=='prt') %>%
+                           setNames(c(names(.)[1], paste0('prt_',names(.)[-1])))
+                         ,by='id')%>%
+             dplyr::select(-prt_dtname,-dtname)
+         }
+   all_GQSfled_0_delayed <- GQSfled_0 %>%   
+     filter(delayE0>=0)
+   group_by_delay <- unique(all_GQSfled_0_delayed$delayE0)
+   picked_genes <- data.frame()
+   
+   for (delay in group_by_delay){
+     GQSfled_0_delayed <- 
+       all_GQSfled_0_delayed[order(all_GQSfled_0_delayed$scoreE0),] %>%
+       filter(delayE0==delay)
+     mstScoreMat <- GQScoreMat_0 %>%
+       filter(id %in% GQSfled_0_delayed$id)  
+     dimnames(mstScoreMat)[[1]] <- mstScoreMat$id
+     annMstScoreMat <- mstScoreMat[,-1]
+     
+     HCA_Ward <- hclust(
+       dist(annMstScoreMat),
+       method=methodHclust
+       )
+     plot(HCA_Ward,cex = 0.5)
+     
+     pdf(
+       sprintf(
+         '%s%s_%s_%s_delay%s_%s_nboot%s_sb%s_output.pdf',
+         outputDirectry.prefix,
+         outprefix,
+         bioproc,
+         HCA_by_delay.pdf.prefix,
+         delay,
+         score4HCA,
+         nboot,
+         sb.switch
+         ),
+       width=100,
+       paper='USr'
+       )
+   pv <- silent.pvclust(
+     data=t(annMstScoreMat),
+     methodHclust,methodDist,nboot
+     )
+   
+   #++++++ scale boot ++ added in 2015/11/27
+ pv.sb <- sbfit(pv)
+ 
+ 
+ sink(file = sprintf(fmt =
+                       sprintf(
+                         '%s%s_%s_%s_delay%s_%s_nboot%s_sb%s_output.txt',
+                         outputDirectry.prefix,
+                         outprefix,
+                         bioproc,
+                         HCA_by_delay.pdf.prefix,
+                         delay,
+                         score4HCA,
+                         nboot,
+                         sb.switch
+                         )
+                     )
+      )
+ print(summary(pv.sb,k=c(1:3)))
+ sink()
+ 
+ if(ScaleBoot==TRUE){
+   pv  <- sbpvclust(pv, pv.sb)
+ }
+   #++++++ end (added in 2015/11/27)
+ 
+   plot(pv,cex.pv=0.1,lwd=0.5,cex=0.1)
+   for(edges in 1:nrow(pv$edges)){
+      msplot(pv,edges)
+     }
+   pvcl_se <- seplot(pv, identify=TRUE)
+   plot(pv,cex=0.5)
+   dev.off()
+ 
+     pv.picked <- my.pvrect(
+       pv,
+       alpha.au = alpha.au ,
+       alpha.bp = alpha.bp ,
+       pv='bp',
+       type='gt'
+       )
+   if(!is.null(pv.picked$clusters[[1]])){
+     for( i in 1:length(pv.picked$edges)){
+       for( j in 1:length(pv.picked$clusters[[i]])){
+         d.f_ij <-  data.frame(pv.picked$clusters[[i]][j],
+                               pv.picked$edges[[i]],
+                               delay
+                               )
+         picked_genes <- rbind(picked_genes,d.f_ij)
+         }
+       }
+     }
+ 
+   pv_df <- data.frame(pv$edges)
+   write.csv(
+     pv_df, 
+     file=sprintf(
+       '%s%s_%s_%s_delay%s_%s_nboot%s_sb%s.csv',
+       outputDirectry.prefix,
+       outprefix,
+       bioproc,
+       BP_of_edges.csv.prefix,
+       delay,
+       score4HCA,
+       nboot,
+       sb.switch
+       )
+     , col.names=T
+     , quote=F
+     , row.names=T
+   )
+   
+   
+   pdf(sprintf('%s%s_%s_%s_%s_output.pdf',
+               outputDirectry.prefix,
+               outprefix,
+               bioproc,
+               heatmap_by_delay.pdf.prefix,
+               delay
+               ),
+       width=8,
+       height=8
+       )
+   GQScoreHeatmap_0 <-
+     dlply(
+       mst %>% filter(id %in% dimnames(annMstScoreMat)[[1]]), 
+       .(id),
+       gq_scoreMatOut_withName) %>% 
+     llply(my.heatmap.3)
+   dev.off()  
+   }
+   picked_genes <- picked_genes %>%
+     dplyr::rename(id=pv.picked.clusters..i...j., edges=pv.picked.edges..i..) %>%
+     filter(delay %in% filter.delay)
+   
+   }else{ # end:if(score4HCA != 'noHCA')
+     picked_genes <- data.frame()
+     pv.picked <- GQSfled_0 %>%
+       dplyr::select(id,delayE0) %>%
+       dplyr::rename(delay=delayE0) %>%
+       mutate(edges=bioproc) %>%
+       dplyr::select(id,edges,delay)
+     for( i in 1:length(pv.picked$edges)){
+       d.f_ij <-  data.frame(pv.picked$id[[i]],
+                             pv.picked$edges[[i]],
+                             pv.picked$delay[[i]]
+                             )
+       picked_genes <- rbind(picked_genes,d.f_ij)
+       }
+     picked_genes <- picked_genes %>%
+       dplyr::rename(
+         id=pv.picked.id..i.., 
+         edges=pv.picked.edges..i..,
+         delay=pv.picked.delay..i..) %>%
+       filter(delay %in% filter.delay)
+     }
> 
> #```
> 
> #```{r using BioMart output}
> 
> inputName_to_outputName <- picked_genes %>%
+   inner_join(
+     read.csv(
+       sprintf('%s%s',
+               dataDirectry,
+               id.convertData
+               )
+       )
+     ) %>%
+   dplyr::rename(accession=uniid)
Joining by: "id"
 警告メッセージ: 
 inner_join_impl(x, y, by$x, by$y) で: 
  joining factors with different levels, coercing to character vector
> 
> edge_to_inputName_to_outputName = picked_genes %>%
+   full_join(inputName_to_outputName)
Joining by: c("id", "edges", "delay")
 警告メッセージ: 
 outer_join_impl(x, y, by$x, by$y) で: 
  joining character vector and factor, coercing into character vector
> 
> sum(is.na(edge_to_inputName_to_outputName))
[1] 0
> sum(duplicated(edge_to_inputName_to_outputName$id))
[1] 0
> 
> pander(edge_to_inputName_to_outputName)

-----------------------------------------------
  id         edges       delay   X   accession 
------- --------------- ------- --- -----------
YAL012W GlySerThrMetabo    0    22    P31373   

YBR263W GlySerThrMetabo    0     4    P37292   

YCR053W GlySerThrMetabo    0    16    P16120   

YDL021W GlySerThrMetabo    0    12    Q12008   

YDR158W GlySerThrMetabo    0    24    P13663   

YEL046C GlySerThrMetabo    0    11    P37303   

YER026C GlySerThrMetabo    0    14    P08456   

YER052C GlySerThrMetabo    0     1    P10869   

YER086W GlySerThrMetabo    0    25    P00927   

YFL018C GlySerThrMetabo    0     9    P09624   

YGR155W GlySerThrMetabo    0    13    P32582   

YGR208W GlySerThrMetabo    0    10    P42941   

YHR025W GlySerThrMetabo    0    26    P17423   

YJR139C GlySerThrMetabo    0    21    P31116   

YKR043C GlySerThrMetabo    0     8    P36136   

YLR058C GlySerThrMetabo    0     6    P37291   

YMR189W GlySerThrMetabo    0    19    P49095   

YOR283W GlySerThrMetabo    0     5    Q12040   

YDR019C GlySerThrMetabo    1    23    P48015   

YGR205W GlySerThrMetabo    1    17    P42938   

YIL074C GlySerThrMetabo    1    18    P40510   
-----------------------------------------------

> write.csv2(
+   edge_to_inputName_to_outputName,
+   sprintf(
+     '%s%s_%s_%s_%s_nboot%s_sb%s.csv',
+     outputDirectry.prefix,
+     outprefix,
+     bioproc,
+     uniProtAccess.csv.prefix,
+     score4HCA,
+     nboot,
+     sb.switch
+     )
+   )
> 
> #```
> 
> 
> #```{r Spearmans Rho }
> 
> # If inputName has duplicated outputName, 
> # then choose the first one.
> 
> df.genes <- ddply( 
+   edge_to_inputName_to_outputName[
+     !(duplicated(edge_to_inputName_to_outputName$id)),],
+   .(delay,edges),
+   paste
+   ) %>%
+   dplyr::select(-V2,-V3)
> 
> df.genes.notDelay <- ddply( 
+   edge_to_inputName_to_outputName[
+     !(duplicated(edge_to_inputName_to_outputName$id)),],
+   .(edges),
+   paste
+   ) %>%
+   dplyr::select(-V2,-V3)
> 
> if(rho.interTemporal==TRUE){
+   edge.dataGQ <-
+     inner_join(
+       dataGQ,
+       edge_to_inputName_to_outputName,
+       by='id'
+     )
+   annMstLong <- edge.dataGQ %>%
+     gather(var,val,starts_with('d_')) %>%
+     spread(dtname,val) %>%
+     mutate(
+       var.prt = match(
+         var,
+         names(
+           edge.dataGQ %>%
+             dplyr::select(
+               starts_with('d_')
+             )
+         )
+       ), 
+       var.trc = var.prt + delay
+     )
+ }else{
+   edge.dataGQ <-
+     inner_join(
+       data_ana %>%
+         filter(var %in% cols) %>%
+         mutate(var=factor(var,cols)) %>% 
+         spread(key=var,value=val),
+       edge_to_inputName_to_outputName,
+       by='id'
+     )
+   annMstLong <- edge.dataGQ %>%
+     gather(var,val,one_of(cols)) %>%
+     spread(dtname,val) %>%
+     group_by(id) %>%
+     mutate(
+       var.prt = match(
+         var,
+         names(
+           edge.dataGQ %>%
+             dplyr::select(
+               one_of(cols)
+             )
+         )
+       ), 
+       var.trc = var.prt + delay,
+       prt.norm=scale(prt,center=TRUE,scale=TRUE),
+       trc.norm=scale(trc,center=TRUE,scale=TRUE)
+     )%>%
+     ungroup()
+   attributes(annMstLong$prt.norm) <-NULL
+   attributes(annMstLong$trc.norm) <-NULL
+ }
> 
> 
> delayAnnMstLong <- inner_join(
+   annMstLong %>% dplyr::rename(var.new=var.prt) %>% 
+     dplyr::select(id,prt,var.new,prt.norm) ,
+   annMstLong %>% dplyr::rename(var.new=var.trc) %>%
+     dplyr::select(id,trc,var.new,trc.norm,var,edges,delay,accession) ,
+   by = c("id", "var.new")
+   ) %>%
+   dplyr::rename(var.ori=var)
> 
> write.csv(
+   x = data.frame(annMstLong),
+   file = sprintf(
+     fmt = '%s%s_data.csv',
+     outputDirectry.prefix,outprefix)
+     )
> #```
> 
> #```{r plotting line plot}
> 
> # make pdf file of time series line plots
> 
> line.plot <- function(data){
+   id <- data$id[1]
+   accession <- data$accession[1]
+   delay <- data$delay[1]
+   edge  <- data$edges[1]
+   p <- ggplot(data %>%
+                 mutate(timepoint=paste('timepoint #',var.ori)),
+               aes(x=var.ori,y=val,group=var)
+               )
+   plot.type <- geom_line(aes(colour=var),size=1.5)
+   plot.ylim <-coord_cartesian(ylim=c(-2.5,2.5))
+   plot.theme <- theme(
+     legend.background=element_blank(),
+     panel.grid.major=element_blank(), 
+     panel.grid.minor=element_blank(), 
+     panel.background=element_rect(colour="black", fill="white"),
+     axis.text.x = element_text(size=30),
+     axis.text.y = element_text(size=25)
+     )
+   plot.bg    <- theme_bw()
+   plot.title <- labs(
+     list(
+       title = paste(
+         'Gene name_',id,'(',accession,');','Time-lag ; ',delay,'[Cluster;',edge,']',
+         sep=''
+         )
+       )
+     )
+   plot.ylab <- ylab('Normalised')
+   plot( p+ plot.type+ plot.theme + plot.title + plot.ylim + plot.ylab)
+   }
> 
> pdf(
+   sprintf(
+     '%s%s_fixed_y_%s_%s_shifted_%s_nboot%s_sb%s.pdf',
+     outputDirectry.prefix,
+     outprefix,
+     bioproc,
+     line_plot.pdf.prefix,
+     score4HCA,
+     nboot,
+     sb.switch
+     ),
+   width=16,
+   height=10
+   )
>   line.plot.list <- 
+     dlply(
+       delayAnnMstLong %>% 
+         gather(var,val,prt.norm,trc.norm) ,
+       .(delay,edges,id),
+       line.plot
+       ) 
> dev.off()
null device 
          1 
> 
> pdf(
+   sprintf(
+     '%s%s_fixed_y_%s_%s%s_nboot%s_sb%s.pdf',
+     outputDirectry.prefix,
+     outprefix,
+     bioproc,
+     line_plot.pdf.prefix,
+     score4HCA,
+     nboot,
+     sb.switch
+   ),
+   width=16,
+   height=10
+ )
> line.plot.list <- 
+   dlply(
+     annMstLong %>%
+       rename(var.ori=var)%>%
+       gather(var,val,prt.norm,trc.norm) ,
+     .(delay,edges,id),
+     line.plot
+   ) 
> dev.off()
null device 
          1 
> 
> 
> #```
> 
> #```{r plotting scatter plot}
> 
> scat.plot <- function(data){
+   shape_basket <- c(8,15,16,17,18,19)
+ #  shape_basket <- c(9:14) 
+   id <- data$id[1]
+   accession <- data$accession[1]
+   delay <- data$delay[1]
+   edge  <- data$edges[1]
+   RHO   <- cor.test_by.id(data,'prt','trc')$rho.est
+   p <- ggplot(data %>%
+                 mutate(
+                   timepoint=paste('timepoint #',var.new),
+                   cluster=paste('Cluster ;',edges),
+                   delay=paste('Time-lag ; ',delay,sep='')) ,
+               
+               aes(x=trc,y=prt,group=timepoint))
+   
+   if(length(unique(data$id))<=6){
+     plot.type <- geom_point(aes(colour=timepoint,shape=id),size=20,alpha=0.6)
+   }else{
+     plot.type <- geom_point(aes(colour=timepoint,shape=id),size=4,alpha=0.6)
+   }
+ 
+   if(length(unique(data$id))<=6){
+     plot.shape <- scale_shape_manual(
+       values=shape_basket[c(1:length(unique(data$id)))]
+       )
+   }else{
+     plot.shape <- scale_shape_manual(
+       values=rep(16,length(unique(data$id))))
+   }
+   
+   legends.guide <-guides(
+     guide_legend(keywidth = 0.3, keyheight = 0.3,nrow = 2, byrow = TRUE)
+     )
+   plot.ylim <-coord_cartesian(ylim=c(-2.5,2.5))
+   plot.facet <- facet_wrap(~edges+delay)
+   plot.title <- labs(
+     list(
+       title = paste(
+         'Rank Correlation (Rho;',
+         round(RHO,digits = 4),
+         ')'
+         )
+       )
+     )
+   plot.bg <- theme_gray()
+   plot.axe.text <- theme(
+     axis.text.x = element_text(size=30),
+     axis.text.y = element_text(size=30)) 
+   plot( p+ plot.type+ plot.shape + plot.ylim + plot.facet+ plot.title + plot.bg +legends.guide + plot.axe.text )
+ }
> 
> pdf(
+   sprintf(
+     '%s%s_%s_%s_%s_nboot%s_sb%s.pdf',
+     outputDirectry.prefix,
+     outprefix,
+     bioproc,
+     scat_plot.pdf.prefix,
+     score4HCA,
+     nboot,
+     sb.switch
+     )
+   ,width=16,
+   height=10
+   )
>   scat.plot.list <- dlply(
+     data_ana_norm %>% 
+       filter(dtname=='prt') %>% rename(prt=val) %>%
+       inner_join(
+         data_ana_norm %>% 
+           filter(dtname=='trc') %>% rename(trc=val),
+         by=c('id','var')
+         ) %>% 
+       mutate(
+         delay='disabled',
+         edges='All Genes',
+         var.new=factor(var),
+         accession='NA'),
+     .(delay), 
+     scat.plot) # ALL GENES
 警告メッセージ: 
 cor.test.default(data[, x], data[, y], method = method.cor) で: 
  Cannot compute exact p-value with ties
>   
>   scat.plot.list <- dlply(
+     annMstLong %>%
+       rename(raw.prt=prt,raw.trc=trc)%>%
+       rename(prt=prt.norm,trc=trc.norm)%>%
+       mutate(delay='disabled(ALL high BP GENES)',var.new=factor(var)), .(delay), scat.plot)
 警告メッセージ: 
 cor.test.default(data[, x], data[, y], method = method.cor) で: 
  Cannot compute exact p-value with ties
>   
>   scat.plot.list <- dlply(
+     annMstLong %>%
+       rename(raw.prt=prt,raw.trc=trc)%>%
+       rename(prt=prt.norm,trc=trc.norm)%>%
+       mutate(
+         delay='disabled',var.new=factor(var)
+         ),
+     .(edges), scat.plot) 
 警告メッセージ: 
 cor.test.default(data[, x], data[, y], method = method.cor) で: 
  Cannot compute exact p-value with ties
>   
>   scat.plot.list <- dlply(
+     delayAnnMstLong %>%
+       dplyr::rename(raw.prt=prt,raw.trc=trc)%>%
+       dplyr::rename(prt=prt.norm,trc=trc.norm)%>%
+       mutate(
+         delay='disabled',var.new=factor(var)
+         ),
+       .(delay,edges), scat.plot)
 エラー:  unique() はベクトルにのみ使用できます 
 実行が停止されました 
